\chapter{Evaluation}

\section{Final System Evaluation}

In my opinion the final system is well suited for its intended purpose which is to provide a visualisation of Ant Colony Optimisation methods for use in an educational environment. The application meets all of the functional requirements specified in section \ref{funcreq} which confirms that the application provides a solution to the initial problem. The application is fully capable of rendering an automated execution or a step-based iteration of two Ant Colony algorithms. The visualisation process can be heavily controlled through user interaction which enables the modification the algorithms execution speed, loading of configurations from a file, modification of the algorithms parameters and a choice of algorithm types and modifiers

Although I personally feel that the application meets the specified criteria, I am not fully satisfied with the current functionality provided. Before I would consider the deployment of this application I would like to implement some of the additional features discussed in chapter \ref{footure}. The additional features, more specifically the addition of extra Ant Colony algorithm variations would be a high priority and personally they feel necessary in order to create the most suitable environment for the teaching of such methods. The currently implemented algorithm types are not inadequate in anyway, it would just not be in my personal interest to release an application which does not meet my full expectation. The implementation of several algorithm types is beyond the projects scope so some compromise has been made.

On reflection the initial design of the system was extremely inadequate this is due the fact that the projects complexity was underestimated. The process i used enabled me to stray from my proposed design and enabled refactoring and modification of such design to produce the current architecture. The revised design is far more reflective of the problems complexity and it’s far more logical. The decision to adhere to Model-View-Controller principles has allowed myself to produce a framework which is easy to maintain and modify and can be used to display multiple different algorithms as discussed in chapter \ref{footure}. Using Java as the implementation language was a decision I started with and I am glad I did. My personal experience with the language in conjunction with the easy to develop Swing interfaces enabled me to create a simple yet efficient user interface which is cross-platform and accessible by the vast majority of potential users. The current user interface is however far from perfect. The main problem with such interface is that fact that the dimensions of each element are statically defined and as a result the application cannot be resized in anyway. Generally on modern computers the dimensions of the interface will cause no problems but there is the potential for a user using a small display for the user interface render incorrectly resulting in an unusable application.

The process of visualising the algorithms execution is a good basis for future development but the current implementation of some of this visualisation process i am personally not fully satisfied with. As a whole the visualising of the city locations, the pheromone operations and the best route are more than appropriate whereas the visualisation of the agents and their movement between city locations is far from ideal. I wanted to keep the visual representation as simple as possible which I generally feel that I have achieved. As a result of this the agents movement between cities is not as detailed or as informative as I intended. The main problem with the current system is that the ants direction is not represented in anyway which is somewhat problematic. If I had more time I would focus on implementing a better means of displaying an agent’s movement, however given the short development timeframe and the fact that there is some form of visualisation in place i decided to leave it in its current state for now.

The application may meet all of the suggested requirements however, there are overall objectives which are current unachieved. The applications meets 6/9 (~67\%) of the objectives highlighted in section \ref{objy}. This may seem that a large percentage of the objectives have been met and whilst this is technically true, I feel that the easiest objectives has been met and this percentage isn’t truly representative of the remaining work. These remaining objectives relate to specifying a graph to be incomplete as discussed in section \ref{footure}, the implementation of multiple problem representation support and the addition of a larger variety of Ant Colony algorithm variations. Meeting these three objectives is far from trivial but once complete I feel that they will significantly improve the overall user experience and success of the project. 

Aside from the issues mentioned above i feel that the application is on track to outperform the majority of its existing competitors. This applications visualisation process and user interface in far more user friendly and caters for a wider variety of people. If given more time to further develop the project there is no reason why this application could not become one of the best educational tools for the teaching of Ant Colony algorithms. If the project were to be restarted the general approach would remain the same however, I would spend more time on the initial design as I feel I wasted valuable time when I had to redesign and refactor the initial sub-par design. As it currently standards the application should be considered to be in its alpha stage, and will be ready for deployment after the additional features have been implemented and tested.

\section{Personal Evaluation}

The project has been complicated, challenging, interesting and most importantly it has been enjoyable. I have learnt a significant amount about Ant Colony methods and swarm intelligence. I enjoying learning so this has helped me maintain my focus throughout the development process as complicated problems were often infuriating and disheartening.

Generally throughout the course of the projects lifespan I have made reasonable progress. Admittedly i did not make the amount of progress that I would have liked to during the early stages as commitments to other modules in terms of both lectures and assignments restricted the amount of time i had to work on this project. There were breakpoints during the development of the application, once these were broken progress improved significantly. The main breakpoint was the implementation of the underlying Basic Ant System and the user interface which happened to be quite time consuming. Once these had been implemented it became much easier to progress with the application as it was simple to visually test additional features. The main complication during the development was ensuring that the algorithm executed on a separate thread to the user interface in order to prevent the interface from freezing whilst also enabling interaction between the current algorithms state and the view. I was not prepared for this kind of problem and reflecting on this I should have done more research in the early stages of development in order to prevent this kind of complication which ended up costing me a fairly large amount of time. The time lost here could have been put into the testing as the testing process was fairly rushed and I wish I had much more time to perform a series of more detailed tests.

In summary I feel that my project is a successful thus far and has a bright future. I have increased my knowledge in the subject area by a significant amount and I have greatly improved my software development skill set. Personally I have a feeling of self-pride as I have achieved a lot in a relative short space of time both in terms of technical achievement and personal skill development. I underestimated the problem originally and wrongly assumed I could create an interface and implement an algorithm and make the two elements interact and I would have a sufficient application, I am glad to say I have proved myself very wrong. If I were to do this project again I would like to properly time manage so that unforeseen complications weren’t as much of a problem as they were and I would like to have a lengthier test period. I think I have achieved my best work for the time available and the fact that I have met all of the proposed requirements allows me to call this project a success.